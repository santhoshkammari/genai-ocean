# 100 Essential Python Features: Names and Explanations

| # | Feature | Explanation | Code Example                                                                      | Use Case | Importance(1-5)|
|---|---------|-------------|-----------------------------------------------------------------------------------|---------|--------------|
| 1 | functools.lru_cache | Decorator that memoizes a function's return values | ```python @lru_cache(maxsize=100) def fib(n): if n < 2: return fib(n-1) + fib(n-2)```| primarily used for optimizing recursive functions or functions with expensive computations that are called repeatedly with the same arguments | 5 |
| 2 | collections.defaultdict | Dictionary subclass that calls a factory function for missing keys | ```python from collections import defaultdict d = defaultdict(list) d['a'].append(1)  # No KeyError ``` | Simplifying handling of missing dictionary keys | 4 |
| 3 | contextlib.contextmanager | Decorator for creating context managers | ```python @contextmanager def file_manager(filename, mode): f = open(filename, mode) yield f f.close() ``` | Resource management (e.g., file handling) | 4 |
| 4 | itertools.cycle | Creates an infinite iterator | ```pythonfrom itertools import cyclecolors = cycle(['red', 'green', 'blue'])next(colors)  # 'red', then 'green', then 'blue', then 'red' again...``` | Creating repeating sequences | 3 |
| 5 | functools.partial | Creates a new function with pre-filled arguments | ```pythonfrom functools import partialbasetwo = partial(int, base=2)basetwo('10010')  # Returns 18``` | Creating specialized versions of functions | 4 |
| 6 | typing.Optional | Indicates that a value can be of a specified type or None | ```pythondef greet(name: Optional[str] = None):    print(f"Hello, {name or 'stranger'}!")``` | Improving type hinting and code readability | 4 |
| 7 | collections.Counter | Dict subclass for counting hashable objects | ```pythonfrom collections import Counterc = Counter('hello world')print(c)  # Counter({'l': 3, 'o': 2, ...})``` | Counting occurrences of items in an iterable | 4 |
| 8 | itertools.chain | Combines multiple iterables | ```pythonfrom itertools import chainresult = chain([1, 2, 3], ['a', 'b', 'c'])list(result)  # [1, 2, 3, 'a', 'b', 'c']``` | Flattening nested iterables | 3 |
| 9 | os.path.join | Joins path components intelligently | ```pythonimport ospath = os.path.join('usr', 'bin', 'spam')``` | Creating platform-independent file paths | 5 |
| 10 | pathlib.Path | Object-oriented filesystem paths | ```pythonfrom pathlib import Pathp = Path('.')[x for x in p.iterdir() if x.is_dir()]``` | Modern, object-oriented file path handling | 4 |
| 11 | dataclasses.dataclass | Decorator for automatically adding generated special methods to classes | ```pythonfrom dataclasses import dataclass@dataclassclass Point:    x: float    y: float``` | Creating simple classes with less boilerplate | 4 |
| 12 | asyncio | Library for writing concurrent code | ```pythonimport asyncioasync def main():    print('Hello')    await asyncio.sleep(1)    print('World')asyncio.run(main())``` | Writing asynchronous, concurrent code | 5 |
| 13 | functools.wraps | Decorator factory to apply update_wrapper() to a wrapper function | ```pythonfrom functools import wrapsdef my_decorator(f):    @wraps(f)    def wrapper(*args, **kwds):        print('Calling decorated function')        return f(*args, **kwds)    return wrapper``` | Preserving metadata of decorated functions | 4 |
| 14 | abc.ABC and @abc.abstractmethod | For defining abstract base classes | ```pythonfrom abc import ABC, abstractmethodclass Animal(ABC):    @abstractmethod    def make_sound(self):        pass``` | Creating interfaces and abstract classes | 4 |
| 15 | enum.Enum | For creating enumerated constants | ```pythonfrom enum import Enumclass Color(Enum):    RED = 1    GREEN = 2    BLUE = 3``` | Defining a set of named constants | 3 |
| 16 | logging | Flexible event logging system | ```pythonimport logginglogging.basicConfig(level=logging.INFO)logging.info('Starting program')``` | Adding logging to applications | 5 |
| 17 | argparse | Parser for command-line options and arguments | ```pythonimport argparseparser = argparse.ArgumentParser()parser.add_argument('--verbose', action='store_true')args = parser.parse_args()``` | Handling command-line arguments | 4 |
| 18 | collections.namedtuple | Factory function for creating tuple subclasses with named fields | ```pythonfrom collections import namedtuplePoint = namedtuple('Point', ['x', 'y'])p = Point(11, y=22)``` | Creating simple classes for storing data | 3 |
| 19 | itertools.groupby | Groups consecutive items in an iterable | ```pythonfrom itertools import groupbythings = [("animal", "bear"), ("animal", "duck"), ("plant", "cactus")]for key, group in groupby(things, lambda x: x[0]):    print(key, list(group))``` | Grouping data in iterables | 3 |
| 20 | functools.reduce | Apply a function of two arguments cumulatively to the items of a sequence | ```pythonfrom functools import reducenumbers = [1, 2, 3, 4]sum = reduce(lambda a, b: a + b, numbers)``` | Performing cumulative calculations on sequences | 3 |
| 21 | itertools.combinations | Returns r length subsequences of elements from the input iterable | ```pythonfrom itertools import combinationsprint(list(combinations('ABC', 2)))  # [('A', 'B'), ('A', 'C'), ('B', 'C')]``` | Generating all possible combinations | 3 |
| 22 | contextlib.suppress | Context manager to suppress specified exceptions | ```pythonfrom contextlib import suppresswith suppress(FileNotFoundError):    os.remove('somefile.tmp')``` | Ignoring specific exceptions | 3 |
| 23 | functools.singledispatch | Transforms a function into a single-dispatch generic function | ```pythonfrom functools import singledispatch@singledispatchdef fun(arg):    print("Default")@fun.register(int)def _(arg):    print("Integer")``` | Implementing function overloading | 3 |
| 24 | itertools.islice | Makes an iterator that returns selected elements from the iterable | ```pythonfrom itertools import isliceprint(list(islice('ABCDEFG', 2, None)))  # ['C', 'D', 'E', 'F', 'G']``` | Slicing iterators | 3 |
| 25 | collections.deque | List-like container with fast appends and pops on either end | ```pythonfrom collections import dequed = deque('ghi')d.append('j')d.appendleft('f')``` | Implementing queues and stacks | 4 |
| 26 | itertools.product | Cartesian product of input iterables | ```pythonfrom itertools import productprint(list(product('ABCD', 'xy')))  # [('A', 'x'), ('A', 'y'), ('B', 'x'), ...]``` | Generating all combinations of multiple iterables | 3 |
| 27 | functools.total_ordering | Class decorator that fills in missing ordering methods | ```pythonfrom functools import total_ordering@total_orderingclass Student:    def __eq__(self, other):        return self.grade == other.grade    def __lt__(self, other):        return self.grade < other.grade``` | Simplifying the implementation of comparison methods | 3 |
| 28 | itertools.count | Makes an iterator that returns evenly spaced values | ```pythonfrom itertools import countfor i in count(10):    if i > 20: break    print(i)  # 10 11 12 13 14 15 16 17 18 19 20``` | Creating infinite sequences | 2 |
| 29 | functools.cached_property | Transforms a method into a property whose value is computed once and cached | ```pythonfrom functools import cached_propertyclass DataSet:    @cached_property    def expensive_computation(self):        # Compute something        return result``` | Optimizing expensive computations in classes | 4 |
| 30 | typing.TypedDict | A type for dictionaries with a fixed set of keys | ```pythonfrom typing import TypedDictclass Movie(TypedDict):    name: str    year: intmovie: Movie = {'name': 'Blade Runner', 'year': 1982}``` | Improving type hinting for dictionaries | 3 |
| 31 | contextlib.ExitStack | A context manager that allows you to easily use any number of context managers in a single with statement | ```pythonfrom contextlib import ExitStackwith ExitStack() as stack:    file1 = stack.enter_context(open('file1.txt'))    file2 = stack.enter_context(open('file2.txt'))    # work with file1 and file2``` | Managing multiple context managers | 3 |
| 32 | itertools.permutations | Return successive r length permutations of elements in the iterable | ```pythonfrom itertools import permutationsprint(list(permutations('ABC', 2)))  # [('A', 'B'), ('A', 'C'), ('B', 'A'), ('B', 'C'), ('C', 'A'), ('C', 'B')]``` | Generating all possible permutations | 3 |
| 33 | functools.cmp_to_key | Convert a cmp= function into a key= function | ```pythonfrom functools import cmp_to_keysorted(['10', '2', '1'], key=cmp_to_key(lambda a, b: int(a) - int(b)))``` | Creating key functions for sorting | 2 |
| 34 | itertools.takewhile | Make an iterator that returns elements from the iterable as long as the predicate is true | ```pythonfrom itertools import takewhileprint(list(takewhile(lambda x: x<5, [1,4,6,4,1])))  # [1, 4]``` | Filtering sequences based on a condition | 3 |
| 35 | typing.Union | Used to indicate that a value can be one of several types | ```pythonfrom typing import Uniondef process_item(item: Union[int, str]):    print(item)``` | Improving type hinting for multiple types | 4 |
| 36 | functools.update_wrapper | Update a wrapper function to look like the wrapped function | ```pythonfrom functools import update_wrapperdef wrapper(f):    def wrapped(*args, **kwargs):        return f(*args, **kwargs)    return update_wrapper(wrapped, f)``` | Preserving metadata in decorator patterns | 3 |
| 37 | itertools.tee | Return n independent iterators from a single iterable | ```pythonfrom itertools import teeit = iter([1, 2, 3])it1, it2 = tee(it)``` | Creating multiple iterators from a single iterable | 2 |
| 38 | contextlib.closing | Returns a context manager that closes thing upon completion of the block | ```pythonfrom contextlib import closingfrom urllib.request import urlopenwith closing(urlopen('http://www.python.org')) as page:    for line in page:        print(line)``` | Ensuring resources are closed after use | 3 |
| 39 | itertools.repeat | Make an iterator that returns object over and over again | ```pythonfrom itertools import repeatlist(zip(range(3), repeat('A')))  # [(0, 'A'), (1, 'A'), (2, 'A')]``` | Creating repeating sequences | 2 |
| 40 | typing.Callable | Used to indicate that a value is a callable (function) | ```pythonfrom typing import Callabledef apply_operation(x: int, y: int, operation: Callable[[int, int], int]) -> int:    return operation(x, y)``` | Improving type hinting for function arguments | 4 |
| 41 | itertools.chain.from_iterable | Alternative constructor for chain(). Gets chained inputs from a single iterable argument | ```pythonfrom itertools import chainprint(list(chain.from_iterable(['ABC', 'DEF'])))  # ['A', 'B', 'C', 'D', 'E', 'F']``` | Flattening nested iterables | 3 |
| 42 | typing.Any | Special type indicating an unconstrained type | ```pythonfrom typing import Anydef accept_anything(arg: Any) -> None:    print(arg)``` | Indicating a function can accept any type | 3 |
| 43 | functools.partialmethod | Method descriptor with partial application of the given arguments and keywords | ```pythonfrom functools import partialmethodclass Cell:    def set_state(self, state):        self.state = state    set_alive = partialmethod(set_state, 'alive')``` | Creating specialized methods | 2 |
| 44 | itertools.compress | Make an iterator that filters elements from data returning only those that have a corresponding element in selectors that evaluates to True | ```pythonfrom itertools import compressprint(list(compress('ABCDEF', [1,0,1,0,1,1])))  # ['A', 'C', 'E', 'F']``` | Filtering one iterable with another | 2 |
| 45 | typing.Dict | Used to indicate that a value is a dictionary with specific key and value types | ```pythonfrom typing import Dictdef process_dict(d: Dict[str, int]) -> None:    for key, value in d.items():        print(f"{key}: {value}")``` | Improving type hinting for dictionaries | 4 |
| 46 | itertools.starmap | Make an iterator that computes the function using arguments obtained from the iterable | ```pythonfrom itertools import starmapprint(list(starmap(pow, [(2,5), (3,2), (10,3)])))  # [32, 9, 1000]``` | Applying a function to arguments from an iterable | 2 |
| 47 | functools.singledispatchmethod | Transforms a method into a single-dispatch generic function | ```pythonfrom functools import singledispatchmethodclass Formatter:    @singledispatchmethod    def format(self, arg):        return f"Default: {arg}"    @format.register    def _(self, arg: int):        return f"Integer: {arg}"``` | Implementing method overloading in classes| 3| 
| 48 | itertools.zip_longest | Make an iterator that aggregates elements from each of the iterables | ```pythonfrom itertools import zip_longestfor i in zip_longest('ABCD', 'xy', fillvalue='-'):    print(i)  # ('A', 'x'), ('B', 'y'), ('C', '-'), ('D', '-')``` | Combining iterables of unequal length | 3 |
| 49 | functools.cache | Simple lightweight unbounded function cache | ```pythonfrom functools import cache@cachedef factorial(n):    return n * factorial(n-1) if n else 1``` | Memoizing function results | 4 |
| 50 | itertools.dropwhile | Make an iterator that drops elements from the iterable as long as the predicate is true | ```pythonfrom itertools import dropwhileprint(list(dropwhile(lambda x: x<5, [1,4,6,4,1])))  # [6, 4, 1]``` | Filtering sequences based on a condition | 3 |
| 51 | typing.Literal | A type that can be used to indicate that a value is constrained to a set of possible values | ```pythonfrom typing import Literaldef align(position: Literal['left', 'center', 'right']):    print(f"Aligning {position}")``` | Constraining function parameters to specific values | 3 |
| 52 | functools.partial | Create a new function with partial application of the given arguments | ```pythonfrom functools import partialbasetwo = partial(int, base=2)basetwo('10010')  # Returns 18``` | Creating specialized versions of functions | 4 |
| 53 | itertools.combinations_with_replacement | Return r length subsequences of elements from the input iterable allowing individual elements to be repeated | ```pythonfrom itertools import combinations_with_replacementprint(list(combinations_with_replacement('ABC', 2)))  # [('A','A'), ('A','B'), ('A','C'), ('B','B'), ('B','C'), ('C','C')]``` | Generating combinations with repetition | 2 |
| 54 | typing.Protocol | Define structural subtyping protocols | ```pythonfrom typing import Protocolclass Drawable(Protocol):    def draw(self) -> None: ...def draw_all(drawables: List[Drawable]) -> None:    for d in drawables:        d.draw()``` | Implementing duck typing with static type checking | 4 |
| 55 | functools.reduce | Apply a function of two arguments cumulatively to the items of a sequence | ```pythonfrom functools import reducereduce(lambda x, y: x+y, [1, 2, 3, 4, 5])  # Returns 15``` | Performing cumulative calculations on sequences | 3 |
| 56 | itertools.pairwise | Return successive overlapping pairs taken from the input iterable | ```pythonfrom itertools import pairwisefor pair in pairwise([1, 2, 3, 4]):    print(pair)  # (1, 2), (2, 3), (3, 4)``` | Processing consecutive pairs in a sequence | 3 |
| 57 | typing.NewType | Create distinct types to help catch logical errors | ```pythonfrom typing import NewTypeUserId = NewType('UserId', int)user_id = UserId(524313)``` | Creating more specific types for better type checking | 3 |
| 58 | functools.wraps | Decorator factory to apply update_wrapper() to a wrapper function | ```pythonfrom functools import wrapsdef my_decorator(f):    @wraps(f)    def wrapper(*args, **kwds):        print('Calling decorated function')        return f(*args, **kwds)    return wrapper``` | Preserving metadata of decorated functions | 4 |
| 59 | itertools.accumulate | Make an iterator that returns accumulated sums | ```pythonfrom itertools import accumulateprint(list(accumulate([1,2,3,4,5])))  # [1, 3, 6, 10, 15]``` | Calculating running totals | 3 |
| 60 | typing.Annotated | Add context-specific metadata to a type | ```pythonfrom typing import AnnotatedUserId = Annotated[int, "User ID must be positive"]def process_user(user_id: UserId):    ...``` | Adding metadata to type hints | 3 |
| 61 | functools.total_ordering | Class decorator that fills in missing ordering methods | ```pythonfrom functools import total_ordering@total_orderingclass Student:    def __eq__(self, other):        return self.grade == other.grade    def __lt__(self, other):        return self.grade < other.grade``` | Simplifying the implementation of comparison methods | 3 |
| 62 | itertools.filterfalse | Make an iterator that filters elements from iterable returning only those for which the predicate is False | ```pythonfrom itertools import filterfalseprint(list(filterfalse(lambda x: x%2, range(10))))  # [0, 2, 4, 6, 8]``` | Filtering sequences based on a condition | 3 |
| 63 | typing.TypeVar | Create a type variable | ```pythonfrom typing import TypeVar, ListT = TypeVar('T')def first(l: List[T]) -> T:    return l[0]``` | Creating generic types | 4 |
| 64 | functools.lru_cache | Decorator to wrap a function with a memoizing callable that saves up to the maxsize most recent calls | ```pythonfrom functools import lru_cache@lru_cache(maxsize=None)def fib(n):    if n < 2:        return n    return fib(n-1) + fib(n-2)``` | Optimizing recursive functions or expensive computations | 5 |
| 65 | itertools.groupby | Make an iterator that returns consecutive keys and groups from the iterable | ```pythonfrom itertools import groupbyanimals = ['duck', 'eagle', 'rat', 'giraffe', 'bear', 'bat', 'dolphin', 'shark', 'lion']animals.sort(key=lambda x: x[0])for letter, animals in groupby(animals, key=lambda x: x[0]):    print(letter, list(animals))``` | Grouping data in sorted iterables | 3 |
| 66 | typing.cast | Cast a value to a type | ```pythonfrom typing import List, castdef process_items(items: List[object]):    for item in items:        item = cast(str, item)        print(item.upper())``` | Overriding type inference | 3 |
| 67 | functools.singledispatch | Transform a function into a single-dispatch generic function | ```pythonfrom functools import singledispatch@singledispatchdef fun(arg):    print("Default")@fun.register(int)def _(arg):    print("Integer")``` | Implementing function overloading | 3 |
| 68 | itertools.islice | Make an iterator that returns selected elements from the iterable | ```pythonfrom itertools import isliceprint(list(islice('ABCDEFG', 2, None, 2)))  # ['C', 'E', 'G']``` | Slicing iterators | 3 |
| 69 | typing.overload | Decorator for defining multiple versions of a function | ```pythonfrom typing import overload, Union@overloaddef process(x: None) -> None:    ...@overloaddef process(x: int) -> str:    ...def process(x: Union[None, int]) -> Union[None, str]:    if x is None:        return None    return str(x)``` | Providing more precise type hints for functions | 4 |
| 70 | functools.partial | Create a new function with partial application of the given arguments | ```pythonfrom functools import partialbasetwo = partial(int, base=2)basetwo('10010')  # Returns 18``` | Creating specialized versions of functions | 4 |
| 71 | itertools.tee | Return n independent iterators from a single iterable | ```pythonfrom itertools import teeit = iter([1, 2, 3])it1, it2 = tee(it)``` | Creating multiple iterators from a single iterable | 2 |
| 72 | typing.NamedTuple | Typed version of collections.namedtuple | ```pythonfrom typing import NamedTupleclass Point(NamedTuple):    x: float    y: floatp = Point(1.0, 2.0)``` | Creating simple classes for storing data with type hints | 3 |
| 73 | functools.update_wrapper | Update a wrapper function to look like the wrapped function | ```pythonfrom functools import update_wrapperdef wrapper(f):    def wrapped(*args, **kwargs):        return f(*args, **kwargs)    return update_wrapper(wrapped, f)``` | Preserving metadata in decorator patterns | 3 |
| 74 | itertools.takewhile | Make an iterator that returns elements from the iterable as long as the predicate is true | ```pythonfrom itertools import takewhileprint(list(takewhile(lambda x: x<5, [1,4,6,4,1])))  # [1, 4]``` | Filtering sequences based on a condition | 3 |
| 75 | typing.Final | Declare names that cannot be reassigned | ```pythonfrom typing import FinalMAX_SIZE: Final = 9000``` | Declaring constants | 3 |
| 76 | functools.cmp_to_key | Convert a cmp= function into a key= function | ```pythonfrom functools import cmp_to_keysorted(['10', '2', '1'], key=cmp_to_key(lambda a, b: int(a) - int(b)))``` | Creating key functions for sorting | 2 |
| 77 | itertools.repeat | Make an iterator that returns object over and over again | ```pythonfrom itertools import repeatlist(zip(range(3), repeat('A')))  # [(0, 'A'), (1, 'A'), (2, 'A')]``` | Creating repeating sequences | 2 |
| 78 | typing.Callable | Used to indicate that a value is a callable (function) | ```pythonfrom typing import Callabledef apply_operation(x: int, y: int, operation: Callable[[int, int], int]) -> int:    return operation(x, y)``` | Improving type hinting for function arguments | 4 |
| 79 | functools.cached_property | Transform a method into a property whose value is computed once and then cached | ```pythonfrom functools import cached_propertyclass DataSet:    @cached_property    def expensive_computation(self):        # Compute something        return result``` | Optimizing expensive computations in classes | 4 |
| 80 | itertools.product | Cartesian product of input iterables | ```pythonfrom itertools import productprint(list(product('ABCD', 'xy')))  # [('A', 'x'), ('A', 'y'), ('B', 'x'), ...]``` | Generating all combinations of multiple iterables | 3 |
| 81 | typing.Union | Used to indicate that a value can be one of several types | ```pythonfrom typing import Uniondef process_item(item: Union[int, str]):    print(item)``` | Improving type hinting for multiple types | 4 |
| 82 | functools.reduce | Apply a function of two arguments cumulatively to the items of a sequence | ```pythonfrom functools import reducenumbers = [1, 2, 3, 4]sum = reduce(lambda a, b: a + b, numbers)``` | Performing cumulative calculations on sequences | 3 |
| 83 | itertools.chain | Make an iterator that returns elements from the first iterable until it is exhausted, then proceeds to the next iterable | ```pythonfrom itertools import chainresult = chain([1, 2, 3], ['a', 'b', 'c'])list(result)  # [1, 2, 3, 'a', 'b', 'c']``` | Combining multiple iterables | 3 |
| 84 | typing.Any | Special type indicating an unconstrained type | ```pythonfrom typing import Anydef accept_anything(arg: Any) -> None:    print(arg)``` | Indicating a function can accept any type | 3 |
| 85 | functools.partialmethod | Method descriptor with partial application of the given arguments and keywords | ```pythonfrom functools import partialmethodclass Cell:    def set_state(self, state):        self.state = state    set_alive = partialmethod(set_state, 'alive')``` | Creating specialized methods | 2 |
| 86 | itertools.combinations | Return r length subsequences of elements from the input iterable | ```pythonfrom itertools import combinationsprint(list(combinations('ABC', 2)))  # [('A', 'B'), ('A', 'C'), ('B', 'C')]``` | Generating all possible combinations | 3 |
| 87 | typing.Optional | Indicates that a value can be either of a specified type or None | ```pythonfrom typing import Optionaldef greet(name: Optional[str] = None):    print(f"Hello, {name or 'stranger'}!")``` | Improving type hinting and code readability | 4 |
| 88 | functools.total_ordering | Class decorator that fills in missing ordering methods | ```pythonfrom functools import total_ordering@total_orderingclass Student:    def __eq__(self, other):        return self.grade == other.grade    def __lt__(self, other):        return self.grade < other.grade``` | Simplifying the implementation of comparison methods | 3 |
| 89 | itertools.permutations | Return successive r length permutations of elements in the iterable | ```pythonfrom itertools import permutationsprint(list(permutations('ABC', 2)))  # [('A', 'B'), ('A', 'C'), ('B', 'A'), ('B', 'C'), ('C', 'A'), ('C', 'B')]``` | Generating all possible permutations | 3 |
| 90 | typing.Dict | Used to indicate that a value is a dictionary with specific key and value types | ```pythonfrom typing import Dictdef process_dict(d: Dict[str, int]) -> None:    for key, value in d.items():        print(f"{key}: {value}")``` | Improving type hinting for dictionaries | 4 |
| 91 | functools.wraps | Decorator factory to apply update_wrapper() to a wrapper function | ```pythonfrom functools import wrapsdef my_decorator(f):    @wraps(f)    def wrapper(*args, **kwds):        print('Calling decorated function')        return f(*args, **kwds)    return wrapper``` | Preserving metadata of decorated functions | 4 |
| 92 | itertools.count | Make an iterator that returns evenly spaced values starting with number start | ```pythonfrom itertools import countfor i in count(10):    if i > 20: break    print(i)  # 10 11 12 13 14 15 16 17 18 19 20``` | Creating infinite sequences | 2 |